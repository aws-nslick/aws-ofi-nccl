# This file is important and makes it possible for our `m4/commit-info'
# script to derive an appropriate project version string from our git tags, even
# for source trees not maintained with git, and where a premade ./configure
# script is not included.
#
# How does it work? There are three source-tree cases to consider:
#
# 1. (Simplest case, developers/maintainers)
#
#    Obviously, when the source tree is managed by git, `git describe` is
#    available and it's straightforward to define some logic to consult our tags
#    and/or the branch names to derive a version string.
#
# 2. (Complected case, end-user consuming makedist tarball)
#
#    Due to the way autotools/automake works, `./configure --version' emits a
#    statically-defined version that is determined when autoconf runs. This
#    means our commit-info script runs in the context of the source tree of the
#    project maintainer that makes the tarball, not in the context of the source
#    tree of the end-user that calls ./configure.
#
#    As long as project maintainers are working from a full git tree (safe bet),
#    this is exactly the same as (1).
#
# 3. (The tricky case, end-user consuming git-archive tarball)
#
#    Regardless of whether a "github release" is generated and we upload our
#    makedist tarball separately as a release artifact, it's also the case that
#    all git tags and releases (and individual commits, for that matter) can be
#    downloaded as a zip or targz on most git web frontends, including github.
#
#    On our tag and release pages, links for those autogenerated targz/zip files
#    are listed prominently beside our makedist tarballs. We cannot stop someone
#    from using it. So they must continue to be buildable, and they should
#    produce builds that have the same version info as would be found in a build
#    from source.
#
#    Unlike the makedist case, these tarballs are not preconfigured, so the
#    end-user must invoke autoconf themselves. That will invoke our commit-info
#    script, which needs to magically know the version from git tags, without
#    having git.
#
#    Something important to note about the way that these automatic tarballs are
#    generated: it's obviously not viable to store a tarball on disk for every
#    commit ever, on every repo ever to exist on github... So in practice,
#    virtually every git frontend is just invoking git-archive through libgit
#    on-the-fly, which provides an optimized way of generating a tarball or a
#    zip file from an arbitrary ish.
#
#    This matters because git-archive consults .gitattributes files as it builds
#    the archive, and so this can be used to influence its behavior. A vanilla
#    usage of .gitattributes is to exclude certain irrelvant files from
#    inclusion in the archive.
#
#    Here, we're relying on the `export-subst' directive. `./commit-info'
#    contains a export-subst template (basically, a git-log format string
#    wrapped in `$Format:<format options>$'). When git-archive is invoked, it
#    finds this directive, and it replaces the template with whatever metadata
#    is specified.
#
#    For builds on git, it's easy to check if the template string is still the
#    template string and then just query git directly. Otherwise, we can use the
#    template string contents.
#
#    See man gitattributes for more details.
#
commit-info export-subst
